{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p><code>cymyc</code> is a library for numerical differential geometry on Calabi-Yau manifolds written in JAX, enabling performant:</p> <ul> <li>Approximations of useful tensor fields;</li> <li>Computations of curvature-related quantities;</li> <li>Investigations of the complex structure moduli space;</li> </ul> <p>in addition to many other features. </p> <p>If you're completely new to JAX or Python, then start with this example.</p>"},{"location":"#installation","title":"Installation","text":"<p>Pip package here. <pre><code>pip install cymyc\n</code></pre> Requires Python 3.10+ and Jax 0.4.20+.</p>"},{"location":"#documentation-examples","title":"Documentation / examples","text":"<p>Check out https://justin-tan.github.io/cymyc/. </p>"},{"location":"#contributing","title":"Contributing","text":"<p>Please open an issue / pull request if you have suggestions or encounter unexpected behaviour. Additionally, feel free to get in touch anytime to discuss the project.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this library to be useful in academic work, then please cite: (arXiv)</p> <pre><code>@software{cymyc,\n    author = {Butbaia, Giorgi, Tan, Justin, ...},\n    title = {\\textsf{cymyc}: {\\it A \\textsf{{JAX}} package for {C}alabi--{Y}au \n    {M}etrics {Y}ukawas and {C}urvature (to appear)}}\n}\n</code></pre> <p>The source code is available on GitHub.</p>"},{"location":"#related-libraries","title":"Related libraries","text":"<p>Numerical metrics on Calabi-Yaus</p> <ul> <li>cyjax - Machine learning Calabi-Yau metrics with Jax.</li> <li>cymetric - Python library for studying Calabi-Yau metrics.</li> <li>MLGeometry - Machine learning Calabi-Yau metrics</li> </ul> <p>JAX ecosystem</p> <ul> <li>equinox - JAX enhancement suite.</li> <li>flax - Neural network library.</li> </ul>"},{"location":"basics/","title":"The Basics","text":""},{"location":"basics/#philosophy","title":"Philosophy","text":"<p>The pullback metric \\(\\iota^* g\\) may be computed as:</p> \\[     \\iota^* g = J^T g J\\,. \\]"},{"location":"basics/#abstract-nonsense","title":"abstract nonsense","text":"curvature<pre><code>import jax\nimport jax.numpy as jnp\n\nimport numpy as np\n\ndef metric_fn(p):\n    return \n\ndef christoffel_symbols(p):\n    return del_z(p, metric_fn)\n</code></pre> <p>Note</p> <p>This is a note.</p> <p>Tip</p> <p>This is a tip.</p> <p>Info</p> <p>and this is an info block.</p>"},{"location":"api/curvature/","title":"Curvature","text":""},{"location":"api/curvature/#src.curvature","title":"<code>src.curvature</code>","text":"<p>Calculation of various curvature-related quantities for a general Kahler manifold. Note some functions may specialise to the case of a projective variety. In general these functions expect local <code>c_dim</code> complex coordinates <code>z</code> as with the  real and imaginary parts concatenated to form a real-valued <code>2*c_dim</code> vector, <code>x = [Re(z); Im(z)]</code></p>"},{"location":"api/curvature/#src.curvature.del_z","title":"<code>del_z(p: Float[Array, i], fun: Callable[[Array], Array], *args) -&gt; Array</code>","text":"<p>Holomorphic derivative of a function.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords with <code>float</code> type at which <code>fun</code> is evaluated.  Consists of the concatenation of real and imaginary parts along the last axis.</p> required <code>fun</code> <code>callable</code> <p>Locally defined function fun: \\(\\mathbb{R}^m -&gt; \\mathbb{C}^{a,b,c...}\\) sending real-valued  inputs to complex-valued outputs</p> required <p>Returns:</p> Name Type Description <code>dfun_dz</code> <code>array_like</code> <p>Holomorphic derivative of <code>fun</code>.</p> Notes <p>Computes holomorphic Wirtinger derivative, w.r.t. complex \\(p = x + iy\\).</p> \\[ \\frac{\\partial f}{\\partial z} = \\frac{1}{2}\\left( \\frac{\\partial f}{\\partial x} - i \\frac{\\partial f}{\\partial y} \\right) \\] <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = jnp.ones((8,))\n&gt;&gt;&gt; fun = lambda x: jnp.sum(jnp.cos(x))\n&gt;&gt;&gt; del_z(p, fun)\nArray([-0.42073548+0.42073548j, -0.42073548+0.42073548j,\n       -0.42073548+0.42073548j, -0.42073548+0.42073548j], dtype=complex64)\n</code></pre>"},{"location":"api/curvature/#src.curvature.del_bar_z","title":"<code>del_bar_z(p: Float[Array, i], fun: Callable[[Array], Array], *args) -&gt; Array</code>","text":"<p>Anti-holomorphic derivative of a function.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at  which <code>fun</code> is evaluated. Shape [i].</p> required <code>fun</code> <code>callable</code> <p>Locally defined function fun: \\(\\mathbb{R}^m -&gt; \\mathbb{C}^{a,b,c...}\\) sending real-valued  inputs to complex-valued outputs</p> required <p>Returns:</p> Name Type Description <code>dfun_dz_bar</code> <code>array_like</code> <p>Anti-holomorphic derivative of <code>fun</code>.</p>"},{"location":"api/curvature/#src.curvature.del_z_bar_del_z","title":"<code>del_z_bar_del_z(p: Float[Array, i], fun: Callable[[Array], Array], *args, wide: bool = False) -&gt; Array</code>","text":"<p>Computes ddbar of a given function.</p> <p>Expects functions with real domain. Computes the full Hessian matrix corresponding to  \\(\\bar{\\partial} \\partial f\\)</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>fun</code> <code>callable</code> <p>Locally defined function fun: \\(\\mathbb{R}^m -&gt; \\mathbb{C}^{a,b,c...}\\) sending real-valued  inputs to complex-valued outputs</p> required <code>wide</code> <code>Flag to use reverse-mode autodiff if function is wide, i.e. if the output of </code> <p><code>fun</code> is a scalar.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dfun_dz_bar_dz</code> <code>array_like</code> <p>\\(\\bar{\\partial} \\partial f\\). Shape [..., \\mu, \\bar{\\nu}]. Note holomorphic index  comes first.</p>"},{"location":"api/curvature/#src.curvature.christoffel_symbols_kahler","title":"<code>christoffel_symbols_kahler(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"<p>Returns Levi-Civita pullback holomorphic connection, with support for variety \\(\\iota: X \\hookrightarrow P^n\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>metric_fn</code> <code>callable</code> <p>Function representing metric tensor in local coordinates \\(g : \\mathbb{R}^m -&gt; \\mathbb{C}^{a,b...}\\).</p> required <p>Returns:</p> Name Type Description <code>gamma_holo</code> <code>array_like</code> <p>Holomorphic Christoffel symbols of the Kahler metric. \\(\\Gamma^{\\lambda}_{\\mu \\nu}\\). Shape [...,k,i,j], symmetric in (i,j). The Kahler conditions  imply \\(\\Gamma^{\\lambda}_{\\mu \\nu}\\) and its conjugate are the only nonzero connection coeffs.</p> <p>Other Parameters:</p> Name Type Description <code>pullbacks</code> <code>array_like</code> <p>Pullback tensor from ambient to projective variety. If supplied, computes Christoffels on the variety.</p>"},{"location":"api/curvature/#src.curvature.christoffel_symbols_kahler_antiholo","title":"<code>christoffel_symbols_kahler_antiholo(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"<p>Returns Levi-Civita pullback antiholomorphic connection, with support for on variety  \\(\\iota: X \\hookrightarrow P^n\\).</p>"},{"location":"api/curvature/#src.curvature.riemann_tensor_kahler","title":"<code>riemann_tensor_kahler(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None, return_aux: bool = False) -&gt; Array | Sequence[Array]</code>","text":"<p>Returns Riemann tensor on a K\u00e4hler manifold, with support for variety \\(\\iota: X \\hookrightarrow P^n\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>metric_fn</code> <code>callable</code> <p>Function representing metric tensor in local coordinates \\(g : \\mathbb{R}^m -&gt; \\mathbb{C}^{a,b...}\\).</p> <p>Warning</p> <p>This function explicitly instantiates the complex Hessian of <code>metric_fn</code> - this may result in  memory issues if <code>vmap</code>-ing over a large batch. Try reducing the batch size or reducing the complexity of <code>metric_fn</code> if memory-constrained.</p> required <p>Returns:</p> Name Type Description <code>riemann</code> <code>array_like</code> <p>(1,3) Riemann tensor corresponding to the Kahler connection \\(R^{\\kappa}_{\\lambda \\mu \\overline{\\nu}}\\). See page 335, (8.97) of Nakahara.</p> <p>Other Parameters:</p> Name Type Description <code>pullbacks</code> <code>array_like</code> <p>Pullback tensor from ambient to projective variety. If supplied, computes Riemann tensor on the variety.</p>"},{"location":"api/curvature/#src.curvature.ricci_tensor_kahler","title":"<code>ricci_tensor_kahler(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"<p>Returns Ricci tensor on a K\u00e4hler manifold, with support for variety \\(\\iota: X \\hookrightarrow P^n\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>metric_fn</code> <code>callable</code> <p>Function representing metric tensor in local coordinates \\(g : \\mathbb{R}^m -&gt; \\mathbb{C}^{a,b...}\\).</p> required <p>Returns:</p> Name Type Description <code>ricci</code> <code>array_like</code> <p>(0,2) Ricci tensor corresponding to the Kahler connection $ R_{\\mu \\bar{\\nu}}$.</p> <p>Other Parameters:</p> Name Type Description <code>pullbacks</code> <code>array_like</code> <p>Pullback tensor from ambient to projective variety. If supplied, computes Ricci tensor on the variety.</p> See Also <p><code>ricci_form_kahler</code> : Computes Ricci form as \\(\\partial_{\\mu} \\overline{\\partial}_{\\overline{\\nu}} \\log g\\).</p>"},{"location":"api/curvature/#src.curvature.ricci_form_kahler","title":"<code>ricci_form_kahler(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"<p>Returns Ricci form on a K\u00e4hler manifold, with support for variety \\(\\iota: X \\hookrightarrow P^n\\).  Componentwise, \\(\\rho_{\\mu\\bar{\\nu}} = i R_{\\mu \\bar{\\nu}}\\).</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>metric_fn</code> <code>callable</code> <p>Function representing metric tensor in local coordinates \\(g : \\mathbb{R}^m -&gt; \\mathbb{C}^{a,b...}\\).</p> required <p>Returns:</p> Name Type Description <code>ricci</code> <code>array_like</code> <p>(1,1) Ricci form corresponding to the Kahler connection $ R_{\\mu \\bar{\\nu}}$.</p> <p>Other Parameters:</p> Name Type Description <code>pullbacks</code> <code>array_like</code> <p>Pullback tensor from ambient to projective variety. If supplied, computes Ricci tensor on the variety.</p>"},{"location":"api/curvature/#src.curvature.ricci_scalar","title":"<code>ricci_scalar(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"<p>Returns Ricci scalar on a K\u00e4hler manifold, with support for variety \\(\\iota: X \\hookrightarrow P^n\\). </p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>array_like</code> <p>2 * <code>complex_dim</code> real coords at which <code>fun</code> is evaluated. Shape [i].</p> required <code>metric_fn</code> <code>callable</code> <p>Function representing metric tensor in local coordinates \\(g : \\mathbb{R}^m -&gt; \\mathbb{C}^{a,b...}\\).</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>array_like</code> <p>Ricci scalar, \\(R = g^{\\mu \\bar{\\nu}}R_{\\mu \\bar{\\nu}}\\). Shape [...]</p> <p>Other Parameters:</p> Name Type Description <code>pullbacks</code> <code>array_like</code> <p>Pullback tensor from ambient to projective variety. If supplied, computes Ricci tensor on the variety.</p>"},{"location":"api/curvature/#src.curvature.ricci_scalar_from_form","title":"<code>ricci_scalar_from_form(p: Float[Array, i], metric_fn: Callable[[Array], Array], pullbacks: Complex[Array, 'cy_dim i'] = None) -&gt; Array</code>","text":"See Also <p><code>ricci_scalar</code>.</p>"},{"location":"api/example/","title":"Example","text":""},{"location":"api/example/#src.example","title":"<code>src.example</code>","text":"<p>Docstring for the example.py module.</p> <p>Modules names should have short, all-lowercase names.  The module name may have underscores if this improves readability.</p> <p>Every module should have a docstring at the very top of the file.  The module's docstring may extend over multiple lines.  If your docstring does extend over multiple lines, the closing three quotation marks must be on a line by itself, preferably preceded by a blank line.</p>"},{"location":"api/example/#src.example.foo","title":"<code>foo(var1, var2, *args, long_var_name='hi', only_seldom_used_keyword=0, **kwargs)</code>","text":"<p>Summarize the function in one line.</p> <p>Several sentences providing an extended description. Refer to variables using back-ticks, e.g. <code>var</code>.</p> <p>Parameters:</p> Name Type Description Default <code>var1</code> <code>array_like</code> <p>Array_like means all those objects -- lists, nested lists, etc. -- that can be converted to an array.  We can also refer to variables like <code>var1</code>.</p> required <code>var2</code> <code>int</code> <p>The type above can either refer to an actual Python type (e.g. <code>int</code>), or describe the type of the variable in more detail, e.g. <code>(N,) ndarray</code> or <code>array_like</code>.</p> required <code>*args</code> <code>iterable</code> <p>Other arguments.</p> <code>()</code> <code>long_var_name</code> <code>(hi, ho)</code> <p>Choices in brackets, default first when optional.</p> <code>'hi'</code> <p>Returns:</p> Name Type Description <code>type</code> <p>Explanation of anonymous return value of type <code>type</code>.</p> <code>describe</code> <code>type</code> <p>Explanation of return value named <code>describe</code>.</p> <code>out</code> <code>type</code> <p>Explanation of <code>out</code>.</p> <code>type_without_description</code> <p>Other Parameters:</p> Name Type Description <code>only_seldom_used_keyword</code> <code>int</code> <p>Infrequently used parameters can be described under this optional section to prevent cluttering the Parameters section.</p> <code>**kwargs</code> <code>dict</code> <p>Other infrequently used keyword arguments. Note that all keyword arguments appearing after the first parameter specified under the Other Parameters section, should also be described under this section.</p> <p>Raises:</p> Type Description <code>BadException</code> <p>Because you shouldn't have done that.</p> See Also <p>numpy.array : Relationship (optional). numpy.ndarray : Relationship (optional), which could be fairly long, in                 which case the line wraps here. numpy.dot, numpy.linalg.norm, numpy.eye</p> Notes <p>Notes about the implementation algorithm (if needed).</p> <p>This can have multiple paragraphs.</p> <p>You may include some math:</p> <p>\\(X(e^{j\\omega } ) = x(n)e^{ - j\\omega n}\\)</p> <p>And even use a Greek symbol like \\(\\omega\\) inline.</p> References <p>Cite the relevant literature, e.g. [1]_.  You may also cite these references in the notes section above.</p> <p>.. [1] O. McNoleg, \"The integration of GIS, remote sensing,    expert systems and adaptive co-kriging for environmental habitat    modelling of the Highland Haggis using object-oriented, fuzzy-logic    and neural-network techniques,\" Computers &amp; Geosciences, vol. 22,    pp. 585-588, 1996.</p> <p>Examples:</p> <p>These are written in doctest format, and should illustrate how to use the function.</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; print([x + 3 for x in a])\n[4, 5, 6]\n&gt;&gt;&gt; print(\"a\\nb\")\na\nb\n</code></pre>"},{"location":"api/example/#src.example.math_function","title":"<code>math_function(x, y)</code>","text":"<p>Look at these formulas:</p> \\[ f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi \\]"},{"location":"examples/cs_moduli/","title":"Complex structure moduli space","text":"<p>CS moduli</p>"},{"location":"examples/cs_moduli/#mathbbp533-bicubic","title":"\\(\\mathbb{P}^5[3,3]\\) bicubic","text":"<p>Solve geodesic equation</p> \\[ \\frac{\\mathrm{d}^2 \\gamma}{\\mathrm{d} t^2} + \\Gamma^{a}_{bc} \\frac{\\mathrm{d}\\gamma^b}{\\mathrm{d}t}\\frac{\\mathrm{d}\\gamma^c}{\\mathrm{d}t} = 0~. \\] <p>Plot geodesics and stuff.</p>"},{"location":"examples/cs_moduli/#tian-yau-quotient","title":"Tian-Yau quotient","text":"<p>Ditto.</p>"},{"location":"examples/curvature/","title":"Curvature","text":""},{"location":"examples/harmonic_forms/","title":"harmonic forms","text":""},{"location":"examples/ricci_flat_metrics/","title":"blaj","text":""}]}